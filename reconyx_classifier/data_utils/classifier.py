import os
import pandas as pd
import numpy as np
import keras.backend as K
import keras.models
import keras.utils

from keras.applications.inception_resnet_v2 import preprocess_input
from keras.preprocessing.image import ImageDataGenerator, load_img, img_to_array

from typing import Generator, List

# import logging
# log = logging.getLogger(__name__)
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '1'

predict_generator = ImageDataGenerator()
target_im_size = (299 + 20, 299 + 20)


def data_to_matrix(data_batch):
    """Given a dataframe with image paths and metadata, convert to NN input."""
    batch_x = np.zeros((len(data_batch), 299 + 20, 299 + 20, 3),
                       dtype=K.floatx())
    batch_t = np.zeros((len(data_batch),), dtype=K.floatx())
    batch_h = np.zeros((len(data_batch),), dtype=K.floatx())

    for i, (key, row) in enumerate(data_batch.iterrows()):
        img = load_img(row['path'], grayscale=False,
                       target_size=target_im_size)
        x = img_to_array(img)
        x = predict_generator.random_transform(x.astype(K.floatx()))
        x = predict_generator.standardize(x)
        batch_x[i] = x
        batch_t[i] = row['ambient_temp']
        batch_h[i] = row['hour']

    batch_x = batch_x[:, 10:-10, 10:-10, :]
    batch_x = [preprocess_input(batch_x),
               np.stack((batch_t, batch_h), axis=1)]

    return batch_x


class ImageClassifier:
    """The image classifier for the Reconxy images.

    The classifier detects a certain number of classes in the image,
    but at most one class per image currently (e.g. Cheetah or Leopard).
    """

    def __init__(self, model_path: str, batch_size: int):
        """Initialized the classifier with a Keras model.

        :param model_path: string
            Path to the Keras model file.
            The model should output a softmax activation of the classes.
        :param batch_size: int
            Batch size to use for classification.
        """

        # log.info("Initializing ImageClassifier")
        self.model = keras.models.load_model(model_path)
        self.batch_size = batch_size

    def classify_data(self, data: pd.DataFrame,
                      class_labels: List[str]) -> pd.DataFrame:
        """Classify the data described by a Pandas dataframe.

        :param data: pandas.DataFrame
            A data frame with columns containing at least the following:
            file path - path to the image file
            simple_event_key - the event the image belongs to
            event_key - the extended event when 3-image events are merged
        :param class_labels: List[str]
            Labels of the prediction, e.g. ['cheetah', 'leopard', 'unknown']

        :returns: pandas.DataFrame
            The data frame, with a new 'label' column.
        """

        # build a sequence of images+metadata from the dataframe
        data_seq = DataFrameSequence(data, self.batch_size)

        predictions = self.model.predict_generator(
                data_seq, use_multiprocessing=True, verbose=1)

        data['label'] = np.argmax(predictions, axis=1)

        return data

    @staticmethod
    def dataframe_generator(data: pd.DataFrame, batch_size: int) \
            -> Generator[List[np.ndarray], None, None]:
        """Generate classification input from the dataframe information.

        :param data: pandas.DataFrame
            The dataframe generated by the `read_dir_metadata` function.
        :param batch_size: int
            Number of images to process per batch.

        :returns: [numpy.matrix]
            A `batch_size x data_dimension` size list of input matrices.
        """

        for pos in range(0, len(data), batch_size):
            data_batch = data[pos:(pos + batch_size)]
            data_batch = data_to_matrix(data_batch)

            yield data_batch


class DataFrameSequence(keras.utils.Sequence):
    """Holds a sequence of classification derived from a dataframe."""

    def __init__(self, data: pd.DataFrame, batch_size: int):
        self.data = data
        self.batch_size = batch_size

    def __len__(self):
        return int(np.ceil(len(self.data) / float(self.batch_size)))

    def __getitem__(self, index):
        batch = self.data[index * self.batch_size:(index + 1) * self.batch_size]
        data_batch = data_to_matrix(batch)

        return data_batch
